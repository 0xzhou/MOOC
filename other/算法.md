### 复杂度和简单的排序算法

#### 时间复杂度

常数时间操作：一个操作如果和样本的数据量没有关系，每次都是固定时间完成。例如加减乘除，逻辑与或，random access

非常数时间操作：链表(内存非连续)

评价一个算法流程的好坏，先看**时间复杂度指标**，然后在分析在不同数据量下的**实验指标**。



#### 空间复杂度

**选择排序:**

数组 [x x x x x x .... x x x]

第一次循环: N * (查询 + 对比 + 更新) + 1(与首置位交换)

总次数: $a \cdot N^2 + b\cdot N + c$  (按**最差情况**计算)，忽略低此项和最高次项的系数 -> $O(N^2)$ (粗描数据量和计算量的关系)，但是$O(N^2)$的算法不一定任意时间后比$O(N)$的算法更慢。



**冒泡排序:** 与选择排序非常类似

时间复杂度: $O(N^2)$

空间复杂度: $O(1)$



**插入排序**

- [x] 每个子循环是否只进行一次: NO

时间复杂度: $O(N^2)$



**二分法的使用和复杂度分析** 

- **有序**数组中查找一个元素，时间复杂度: $O(log_2N)$
- **局部最小**(!!): 无序数组，且任意两个数**不相等**，返回**任意**一个局部最小的位置 -> 画图，肯定有拐点



常见的优化算法的方向: 1.数据状况 2. 问题性质



#### 异或运算的性质和拓展

异或运算:  ` ^` 就是**无进位相加!!** ->性质 

- 不申请额外空间交换两个数

  ```python
  a = a^b # 
  b = a^b # b = a^b^b -> b = a^0 = a
  a = a^b # a = a^b^a -> a = 0^b =b
  ```

- A是一个数组，有一种数出现了奇数次，剩下所有数出现偶数次，求出现奇数次的数？

  `eor = 0`, 用 `eor` 异或运算数组中的每一个数( 一个数与自身**异或结果为为0**)

- A是一个数组，有**两种**数出现了奇数次，剩下所有数出现偶数次，求两种出现奇数次的数？

  `eor = 0` -> `eor = a^b (eor!=0)某一位为1` -> 设 `a` 与 `b` 在第四位上不一样

  ```python
  eor = 0
  for ele in A:
  	eor = eor ^ ele
  (eor = a^b)
  (eor != 0)
  # eor必然有一个位置为1
  
  # 核心!!!-----------------------------------------
  rightOne = eor & (~eor+1) # 提取最右的1，其余元素为0 !!!
  # ------------------------------------------------
  
  onlyOne = 0
  for ele in A:
      if ele ^ rightOne != 0:
          onlyOne ^= ele #提取最右1索引处为1的奇数次数
  print (onlyOne, (eor ^ onlyOne))
  ```




#### 对数器

生成大量的**随机样本**对算法进行测试，但是需要一种绝对正确的方法，将两种方法的结果进行对比。若大量样本均通过，则可以说进行测试的样本也正确。

平时一定要积累大量的模板: 对数器（ACM大量使用）



#### 递归函数及复杂度



```c++
int mid = L + (R-L)>>1;
%Tricks: m / 2 = m >>1;
```



**master公式**: 计算特定递归算法的时间复杂度

- 模型前提: $T(N)=aT(\frac{N}{b})+ O(N^d)$
  - **子问题等规模**
  - $log_ba<d : O(N^d)$
  - $log_ba>d : O(N^{log_ba})$
  - $log_ba=d : O(N^d * logN)$



 